% !TEX root = ./report.tex

\clearpage
\section{The Inliner}

\unsure[inline]{A graphical flow chart of the architecture?}

The inliner this report describes performs the following when given an RVSDG as
input:

\begin{enumerate}

	\item Scan through the RVSDG, finding all the \applyNode s.

	\item Order the \applyNode s according to the algorithm described in Section
\ref{sub:scheme:ordering_apply_nodes}.

	\item Use the ordering to evaluate each \applyNode~in turn and decide
whether or not to inline all the non-recursive \applyNode s according to the
algorithm described in Section \ref{sub:scheme:inlining_apply_nodes}*.

	\item When all non-recursive \applyNode s have been evaluated, evaluate at
the recursive ones according to the same ordering as the non-recursive ones.
Then decide whether or not to inline each when evaluating them according to the
algorithm described in Section \ref{sub:scheme:inlining_recur_apply_nodes}*.

\end{enumerate}

*Whenever an \applyNode~has been inlined, the RVSDG is ``pruned'' by Jive's
optimizer. Hence, care needs to be taken to ensure that a previously collected
\applyNode~still is present when we evaluate it. Previously inlined \applyNode s
may have caused Jive's pruning to remove this \applyNode .

\subsection{The order of inlining call sites}
\label{sub:scheme:ordering_apply_nodes}

\todo[inline]{Need a figure showing why the order of inlining matters. \\ +
reference to further ideas when that's done/started on.}

The ordering of the \applyNode s we look at when deciding whether or not to
inline them, matters because inlining opportunities might be missed with one
ordering, and unveiled with another.

Our inliner orders them according to a property each node has in Jive,
\lstinline!distance_from_root!. This property gives us an indication of where in
the \textit{call graph} the call site is located, allowing us to iterate through
the call sites with \unsure{Ensure the correctness of this statement. Also, need
to add a statement saying something about bottom up.}a \textit{Depth First
Search} (DFS) top-down through the call graph.

\subsection{Inlining a call site}
\label{sub:scheme:inlining_apply_nodes}

\todo[inline]{Describe the algorithm and inliner conditions we land on after testing.}

When a call site is inlined, the inliner scans through the inlined RVSDG
subgraph copied from the function. Then it evaluates all \applyNode s found in
the subgraph according to the same ordering as used on the one inlined. Finally,
it returns to the next one in the ordered list of \applyNode s from which it got
the original one which was inlined.

The ordering is ensured not to be broken if the original ordering is a top-down
or bottom-up DFS of the RVSDG's call graph.

\subsection{Inlining a call site for a recursive function}
\label{sub:scheme:inlining_recur_apply_nodes}

\todo[inline]{Describe GHC paper's way to inline.}

After all non-recursive \applyNode s are inlined, the inliner has a list of all
the recursive ones sorted in the same order as the non-recursive ones were
evaluated.

The inliner then looks at each recursive \applyNode , and scans the recursive
binding group for \textit{Strongly Connected Components} (SCCs). If an SCC is
found, one \todo{Write how when implemented.}\applyNode~is chosen as breakpoint,
and all the rest of the recursive bindings in the SCC are inlined instead.

If no SCC is found, the recursive \applyNode is
\todo[inline]{Decide on this. Is it unrolled? Or ignored? If unrolled, how many
times?}
