% !TEX root = ./report.tex

\clearpage
\section{The Inliner}
\label{scheme:start}

\todo[inline]{Introduce section with how the RVSDG helps with the different
steps in the below enumerated list.}

The inliner of this project performs the following when given an RVSDG as input:

\begin{enumerate}

	\item Find any and all recursive environments ($\phi$-regions), which
contain RVSDG subgraphs representing function call loops, in the RVSDG:

	\begin{enumerate}
		\item If no $\phi$-regions are found, continue with
Step~\ref{ScanForApplyNodesItem}.

		\item If $\phi$-regions are found, use the approach described
in Section~\ref{sub:scheme:inlining_recur_apply_nodes} to fill a list of
\textit{loop breakers}. These $\lambda$-nodes are \textit{not} to be inlined.
		\label{MakeLoopBreakerListItem}
	\end{enumerate}

	\item Scan through the RVSDG, finding all \applyNode s. Exclude all function
calls calling loop breakers found in Step~\ref{MakeLoopBreakerListItem},
function calls calling functions that are not-statically known, or external
functions. Put a reference to each remaining function call/\applyNode~into a
list.
	\label{ScanForApplyNodesItem}

	\item Order the list of \applyNode s as discussed in
Section~\ref{sub:scheme:ordering_apply_nodes}.
	\label{OrderApplyNodesFoundItem}

	\item Look at each \applyNode~in turn from the list made in
Step~\ref{OrderApplyNodesFoundItem} and decide whether or not to inline it
according to the heuristic discussed in \ref{sub:scheme:inlining_apply_nodes}:
	\label{LookAtNextCallSiteItem}

	\begin{enumerate}
		\item If the \applyNode~is inlined, add any newly copied (inlined)
\applyNode s, following the same criteria as used in
Step~\ref{ScanForApplyNodesItem}, to the list made in the same Step. Continue
with Step~\ref{OrderApplyNodesFoundItem}.

		\item If the \applyNode~is not inlined, continue with
Step~\ref{LookAtNextCallSiteItem}, evaluating the next \applyNode .
		\label{InlineCallSiteItem}
	\end{enumerate}

	\item When the list has been iterated through without inlining any
\applyNode s, the inliner has finished.
\end{enumerate}

\subsection{Inlining a call site}
\label{sub:scheme:inlining_apply_nodes}

To effectively test for an apt heuristic when deciding whether or not to inline
a call site, our approach is based on previous
work~\cite{deshpande2012statically}\cite{AdaptvCompilAndInlingWaterman}. The
approach evaluates theThis
approach utilizes something we call \textit{Inliner Conditions} (ICs) which
evaluate the function invoked by the call site.

Using ICs in this way allows us to write and re-write inlining heuristics
effectively, since we can write them using CNF in the following fashion:
\lstinline"SC < X || SCC < Y || (SCC < Z && LND > W)"

Utilizing the \textit{inlining conditions} described in
Section~\ref{sub:meth:inlining_conditions}, heuristics evaluating the function
invoked by each \applyNode can be written in \textit{Conjunctive Normal Form}
(CNF). This enables an efficient way to search the parameter space for optimal
parameters for the inlining heuristics.

The inliner evaluates each \applyNode~with the given heuristic, and decides
whether or not to inline the call site this \applyNode~represents, depending on
the properties of the function it invokes.

\todo[inline]{Describe the algorithm and inliner conditions we land on after
testing.}

\subsection{The order of call sites inlined}
\label{sub:scheme:ordering_apply_nodes}

\todo[inline]{Need reference to further ideas related to ordering of inlining.}

The inlining conditions we use as criteria for whether or not to inline, only
look at the properties of the function a call site invokes. Hence, when a
successive series of functions call one another, we only consider at one at a
time. Thus, the ordering of the \applyNode s we look at when deciding whether or
not to inline them, matters because inlining opportunities might be missed with
one ordering, and unveiled with another.

Figure~\ref{fig:inline_ordering_ex} illustrates the different outcomes dependent
upon the order we visit each call-site (\applyNode ). If our criteria for
inlining is that the inlined function does not exceed the inlining condition:
\textit{Statement Count} $> 4$, we can inline $\lambda_1 \Rightarrow \lambda_2
\Rightarrow \lambda_3$. However, if we inline $\lambda_3 \Rightarrow \lambda_2$,
then the combined function $\lambda_{2+3}$ will have a SC exceeding the given
limit.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.75\textwidth]{figures/inline_ordering_ex}
	\caption{A minimal example of an RVSDG subgraph, depicting a function call
order in a program.}
	\label{fig:inline_ordering_ex}
\end{figure}

\subsection{Deciding which recursive functions to inline}
\label{sub:scheme:inlining_recur_apply_nodes}

The inliner evaluates all functions, recursive or not, with the same heuristic,
described in Section~\ref{sub:scheme:inlining_apply_nodes}. However, the inliner
of this project only evaluates \textit{some} of the \applyNode s invoking
recursive functions, to ensure termination of the compiler.

\todo[inline]{Describe how we decide which recursive functions we evaluate with
the inlining heuristic.}

Hence, the inliner has a list of recursive functions which it knows \textit{not}
to inline, to ensure termination of the compilation. All other remaining
recursive functions may then be safely inlined with the same criteria as any
non-recursive functions.
