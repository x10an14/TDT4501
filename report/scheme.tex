% !TEX root = ./report.tex

\clearpage
\section{The Inliner}

\unsure[inline]{A graphical flow chart of the architecture?}

In broad strokes, the inliner does two things. It traverses the RVSDG,
collecting all the \applyNode s (1), before it attempts to inline each one in a
certain order (2). This Section will describe how these two actions are
performed when working with the RVSDG IR, while the actual heuristics are
detailed in Section~\ref{sub:method:apply_node_ordering_heur} and Section
\ref{sub:method:apply_node_inlining_heur}.

\subsection{Collecting all function call sites}
\label{sub:scheme:collecting_apply_nodes}

The traversal of the RVSDG to collect all the apply nodes is simple. The inliner
receives the RVSDG graph, iterates through every node of the RVSDG, and makes
reference copies of each \applyNode . Seeing as the RVSDG is a DAG, no care
needs to be taken when it comes to recursive functions in the inital collection,
as nodes representing recursive environments do not have duplicate \applyNode
present in the graph\footnote{As described in Section~\ref{background:RVSDG}.}.

\subsection{The order of inlining call sites}
\label{sub:scheme:ordering_apply_nodes}

\todo[inline]{Need a figure showing why the order of inlining matters. \\ +
reference to further ideas when that's done/started on.}

\subsection{Inlining a call site}
\label{sub:scheme:inlining_apply_nodes}

When the collected \applyNode s from
Section~\ref{sub:scheme:collecting_apply_nodes} are ordered in the order we want
to visit them in, we run the heuristic described in
Section~\ref{sub:method:apply_node_inlining_heur}, or the heuristic described in
Section~\ref{sub:method:recur_apply_node_inlining_heur} dependent upon whether
the function the \applyNode represents is recursive or not.

If the \applyNode passes the check, the inlining is performed by making a copy
of the subgraph contained in the $\lambda$-node the \applyNode is linked to. The
copied subgraph is then put in the RVSDG where the \applyNode was before, with
all edges previously connected to the \applyNode now connected to the copied
subgraph instead.

However, before moving onto the next \applyNode in the list of previously
collected \applyNode s, the inliner goes through the copied subgraph and
attempts to inline all \applyNode s contained within first. Hence, the ordering
described in Section~\ref{sub:scheme:ordering_apply_nodes} is not \todo{find a
good word for this, want to say broken.}X.

After the copied subgraph's potential \applyNode s are dealt with, the inliner
moves on to the next one in the list collected in
Section~\ref{sub:scheme:collecting_apply_nodes}. When all \applyNode s in this
list have passed through the heuristic, and at least one \applyNode has been
inlined, the RVSDG representing the program is optimized (pruned), and the
inliner jumps back to the traversal and starts anew.
