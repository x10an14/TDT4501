% !TEX root = ./stuff.tex

\todo[inline]{Figure out the terms found in papers...}

\section{\cite{GHCPaper}}
\begin{enumerate}

	\item Section 1
\begin{itemize}

	\item ``inlining subsumes''
Something gets removed by inlining.

	\item ``lexical scopes''
Scope of a program/function/block/variable.
From StackOverflow:
\url{http://stackoverflow.com/questions/1047454/what-is-lexical-scope}

	\item ``pure'' (\textit{language})
Program must always return same results with same inputs. There can be no
``side-effect'' which changes the state of the program.

	\item ``explicitly typed'' (\textit{language})
That the compiler knows at compile time (static) what types all the variables
and return values have.
Great explanation: \url{http://programmers.stackexchange.com/questions/181154/type-systems-nominal-vs-structural-explicit-vs-implicit}

	\item ``strictness analysis''
\todo[inline]{Need more research}
\url{http://en.wikipedia.org/wiki/Strictness_analysis}
\url{https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Demand}

	\item ``\textit{let}-floating'' (\textit{Haskell})
Nico: Not important.

	\item ``name capture''
Making sure each name is an unique identifier. This gets complicated when
compiler has to rename things for program correctness. Like when inlining.

\end{itemize}

	\item Section 2
\begin{itemize}

	\item ``\textit{$\beta$}-reduction''
A way of utilizing lambda-calculus to simplify a lambda expression. Closely related to simplifying anonymous functions (lambda functions) in pure functional programming languages like Haskell.

	\item ``invariant'' (\textit{language artifact/variable/expression?})
Constant/Unchanging: Unchanged by mathematical or physical operations or
transformations.

	\item ``\textit{trivial-constructor-argument invariant}'' (\textit{Haskell?
})
See directly above.

	\item ``divergent computations''

	\item ``closure'' (\textit{scopes of functions?})
Ensuring correct lexical scope for (free)variables, mainly needed in languages
permitting nested function.

	\item ``lambda calculus''
An important language, focusing on ``\textit{computational mathematics}''. It is
\textit{Turing complete}, and it can represent any program. As mentioned, it
focuses on the computational operations of a ($\lambda$-)function, unlike
``normal functions'' which focus on their respective inputs and outputs.

	\item ``literals''
The string ``abcd'' is a literal. As is the number 1, when used to assign value
to an integer, just like the string is used to assign value to a string-variable.

	\item ``primitive operators''
Operators that are in one way ``basic'', but not necessarily only (nor all) of
the operations supported by hardware. Think of it as the most basic operators
which together build up all others.

\end{itemize}

	\item Section 3
\begin{itemize}

	\item ``bound variable''
A variable that is not free, that is, a variable which has been specified as an
input to a function call. (The opposite of a free variable, which is a variable
used in a function, but declared outside of it, and not listed as one of its
parameters).

	\item ``recursive binding groups''
When you have calls between groups of recursive functions, complicated
situations arise. See \cite{GHCPaper}, Section 3.5 for example of a ``recursive
binding group''.

	\item ``strongly-connected components''
A group of nodes (\textit{components}) in a DAG where you can reach every other
node/component/vertex from any other. Hence, a DAG might have several \textit
{strongly-connected components}, composed of a multiple of
nodes/vertices/components.

	\item ``contravariantly''
	(\textit{(..) it appears contravariantly in its own definition.})
Best guess: This term refers to variables or functions which are declared, and then used in a manner contradicting the nature of their declaration. Which possibly can become a problem when inlining recursive functions.

	\item ``untyped programs''
Nico: Not relevant.

	\item ``pathological programs''
Forgot, ask Nico again.

	\item ``static analysis''
Analysis at compile time.

\end{itemize}

	\item Section 4
\begin{itemize}

	\item ``hash-consing''

\end{itemize}

\end{enumerate}
