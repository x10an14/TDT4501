% !TEX root = ./report.tex

\section{Introduction}
\label{introduction}

Since the 1950s, compilers have played an important role in the way programming
code is translated into machine languages. In broad terms, compilers perform two
things: The translation of human-readable code to machine language, and
optimizing the translated programs. There exists many optimization techniques
compilers use. One such optimization is inlining, exemplified below in Listing
\ref{lst:inlining}.

\begin{lstlisting}[caption={Function inlining}, label={lst:inlining},
style=customcpp]
int foo(int x){
	return x + 3;
}

int bar(int y){
	return foo(y) + 2;
}

// bar() with foo() inlined:
int bar(int y){
	y + 3 + 2;
}
\end{lstlisting}

Inlining is a straight-forward optimization, which replaces the call of a
function with its body. However, the decision of which functions to inline has
long been treated as ``black magic'', due to the non-existence of a perfect
inlining heuristic. This report attempts to answer exactly that question for the
new compiler backend Jive, introduced shortly.

The benefits of inlining are removal of function call overhead and unveiling of
additional optimizations. The drawbacks are potential code- and work-
duplication, shown in Listings \ref{lst:code-dup} and \ref{lst:work-dup},
respectively. Additionally, inlining can also negatively affect the compile
time, unless optimizations to counteract this are unveiled.

%\begin{paracol}{2}
\begin{lstlisting}[caption={Code duplication through inlining},
label={lst:code-dup}, style=customcpp]
	typedef struct{
		int x;
		int y;
	} coords_t;


	coords_t* foo(){
		coords_t* a = (coords_t*) malloc(sizeof(coords_t));
		a->x = 1; a->y = 2;
		return a;
	}

	coords_t* bar(){
		coords_t* a = foo();
		coords_t* b = foo();

		b->x += a->x; .y += a->y;
		return b;
	}

	// bar() with foo() inlined, with code duplication
	coords_t* bar(){
		// Line which is duplicated unnecessarily
		coords_t* a = (coords_t*) malloc(sizeof(coords_t));
		a->x = 1; a->y = 2;
		// Line which is duplicating unnecessarily
		coords_t* b = (coords_t*) malloc(sizeof(coords_t));
		b->x = 1; b->y = 2;

		b->x += a->x; b.y += a->y;
		return b;
	}
\end{lstlisting}
%\switchcolumn
\begin{lstlisting}[caption={Work duplication if inlined},
label={lst:work-dup}, style=customcpp]
	int foo(int x){
		//Computationally expensive function,
		//such as Fibonacci for very high numbers
	}

	int bar(int y){
		return foo(y) + foo(y+4000);
	}
\end{lstlisting}
%\end{paracol}

\todo[inline]{Todo: Describe layout/outline of paper. What does each section in
turn discuss?}

This report describes the inliner for the new compiler backend Jive. It will
detail the decisions made for its architecture and heuristics. Jive takes code
in intermediate representation (IR) as input and works on a new IR
representation, the regionalized value-state dependence graph
(RVSDG\footnote{Detailed in Section \ref{background:RVSDG}.}).

Not all functions are straight-forward to inline, such as recursive functions.
Recursive functions, the heuristics parameter space, and how the inliner enables
rapid exploration of the parameter space, are other topics this report will
discuss in turn. Recursive functions need to be handled carefully by an inliner
for an additional reason. Not all recursive functions can be inlined, and if one
is inlined incorrectly, it can lead to non-termination of the compiler.

With RVSDG being a new way to represent IR code, this report will also look into
how the RVSDG affects the design of an inliner, and the process of inlining.
Focus will be put on whether the RVSDG simplifies or complicates the
implementation of the inliner, and the process of inlining compared to commonly
used IRs.

Finally, we evaluate the implemented inliner before we conclude. Focus will be
put on how different heuristics have different consequences, in terms of code-
and work-duplication.

Further details of the assignment of this paper can be found in Appendix
\ref{app:projdesc}.
