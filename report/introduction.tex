% !TEX root = ./report.tex

\section{Introduction}
\label{introduction}

Since the 1950s, compilers have translated most, if not all, higher-level
programming languages into machine languages. A compilers purpose is two-fold:
translate human-readable code into machine language (1), and optimize the
translated code (2). There exist many code optimization techniques, such as
\textit{Common Subexpression Elimination} (CSE) and \textit{Dead Code
Elimination} (DCE).

Another one is \textit{inlining}, which replaces the call site of a function
with its body. Listing~\ref{lst:inlining} shows how when function
\lstinline!foo()! is inlined into \lstinline!bar()!, the body of
\lstinline!bar()! will become \lstinline!return y + 3 + 2;!. After the inlining
is performed, the potential for optimization using \textit{Constant Folding}
is unveiled, and can be applied to the body of \lstinline!bar()!.

\begin{lstlisting}[label={lst:inlining}, style=global_customcpp,
caption={Function \lstinline!foo()! inlined into function \lstinline!bar()!.}]
int foo(int x){
	return x + 3;
}

int bar(int y){
	return foo(y) + 2;
}
\end{lstlisting}
\vspace{-4\parskip} %http://tex.stackexchange.com/q/40863

The benefits of inlining are mainly twofold: The first one is the removal of
function call overhead. Function call overhead is the overhead cost in memory
space needed on the stack. Before CPU cache memory and registers became as
spacious as they are now, this could be a very worthwhile optimization in
itself. The second is the potential for unveiling the application of additional
optimizations as shown in Listing~\ref{lst:inlining}.

The drawbacks of inlining are code-duplication, and an increased compile time.
In specific situations, work-duplication can also occur\footnote{As detailed by
P. Jones and Marlow~\cite{GHCPaper}.}. Listing~\ref{lst:code-dup} exemplifies
how inlining can lead to code-duplication, when \lstinline!foo()! is inlined
into \lstinline!bar()!. This happens because the big expression \lstinline!e! in
\lstinline!foo()! is twice copied into \lstinline!bar()!.

However, code-duplication might be negatable if the potential optimization of
CSE is unveiled.

\begin{lstlisting}[label={lst:code-dup}, style=global_customcpp,
caption={Code duplication in \lstinline!bar()!, when inlining \lstinline!foo()!
into \lstinline!bar()!.}]
int foo(int a){
	return e; //Big expression, depending on a
}

int bar(int x, int y){
	return f(x) + f(y);
}
\end{lstlisting}
\vspace{-4\parskip} %http://tex.stackexchange.com/q/40863

If inlining is performed blindly, another drawback occurs if the compiler
attempts to inline recursive functions. Doing so will lead to non-termination of
the compiler, unless recursive functions are recognized and handled specially by
the inliner of the compiler.

Another factor to consider are recursive functions. Inlining recursive functions
uncontrolled leads to non-termination of the compilation. This report will
discuss the following techniques used to avoid this in the project:
\todo[inline]{Finish this paragraph about recursive functions.}

Not all functions are straight-forward to inline, such as recursive functions.
At compile time, the needed depth of recursion might be unknown, leading to
non-termination of the compiler as it tries to inline the recursive function
until the necessary depth. Hence, extra care needs to be taken when trying to
inline recursive functions.

This report describes the construction of an inliner for the Jive compiler
backend. It details the decisions made for the architecture of the inliner. Jive
works on an \textit{intermediate representation} (IR) called
\textit{Regionalized Value-State Dependence Graph}\footnote{Detailed in Section
\ref{background:RVSDG}.} (RVSDG). The RVSDG is a \textit{directed acyclic graph}
(DAG) representing the operations performed by any specific program through
nodes, and any dependences between the nodes with edges.\todo{Add HiPEAC paper
reference to this sentence/end of paragraph.}

\todo[inline]{In the below paragraph; describe layout/outline of paper. What
does each section in turn discuss?}

This report details how the inliner is able to handle recursive functions, and
how the inliner permits the configuration of different heuristics to allow rapid
exploration of the parameter space. How the RVSDG affects the design of an
inliner, and the algorithms used by the heuristics deciding what to inline, are
also detailed in this report. Focus is put on whether the RVSDG simplifies or
complicates the implementation of the inliner, as well as the impact of the
RVSDG on an inliner, and the process of inlining, compared to commonly used IRs.

Finally, the implemented inliner is evaluated before we conclude. In the
evaluation, focus is put on how different heuristics have different
consequences, in terms of code-duplication. A detailed description of the
project assignment can be found in Appendix~\ref{app:projdesc}.
