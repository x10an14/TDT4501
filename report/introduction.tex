% !TEX root = ./report.tex

\section{Introduction}
\label{introduction}

Since the 1950s, compilers have played an important role in the way programming
code is translated into machine languages. In broad terms, compilers perform two
things: The translation of human-readable code to machine language, and
optimizing the translated programs. There exists many optimization that
compilers use, one such optimization is inlining exemplified below in Listing
\ref{lst:inlining}.

\begin{lstlisting}[caption={Function inlining}, label={lst:inlining},
style=customcpp]
int foo(int x){
	return x + 3;
}

int bar(int y){
	return foo(y) + 2;
}

// bar() with foo() inlined:
int bar(int y){
	y + 3 + 2;
}
\end{lstlisting}

Inlining is a straight-forward optimization, which replaces the call of a
function with its body. However the decision of which functions to inline has
long been treated as ``black magic'', due to the non-existence of a perfect
inlining heuristic.

The benefits of inlining are removal of function call overhead and unveiling of
additional optimizations. The drawbacks are potential code- and work-
duplication, shown in Listings \ref{lst:code-dup} and \ref{lst:work-dup},
respectively. Additionally, inlining can also negatively affect the compile
time, unless optimizations to counteract this are unveiled.

%\begin{paracol}{2}
\begin{lstlisting}[caption={Code duplication through inlining},
label={lst:code-dup}, style=customcpp]
	typedef struct{
		int x;
		int y;
	} coords_t;


	coords_t* foo(){
		coords_t* a = (coords_t*) malloc(sizeof(coords_t));
		a->x = 1; a->y = 2;
		return a;
	}

	coords_t* bar(){
		coords_t* a = foo();
		coords_t* b = foo();

		b->x += a->x; .y += a->y;
		return b;
	}

	// bar() with foo() inlined, with code duplication
	coords_t* bar(){
		// Line which is duplicated unnecessarily
		coords_t* a = (coords_t*) malloc(sizeof(coords_t));
		a->x = 1; a->y = 2;
		// Line which is duplicating unnecessarily
		coords_t* b = (coords_t*) malloc(sizeof(coords_t));
		b->x = 1; b->y = 2;

		b->x += a->x; b.y += a->y;
		return b;
	}
\end{lstlisting}

%\switchcolumn

\begin{lstlisting}[caption={Work duplication if inlined},
label={lst:work-dup}, style=customcpp]
	int foo(int x){
		//Computationally expensive function
	}

	int bar(int y){
		return foo(y) + foo(y+1);
	}
\end{lstlisting}
%\end{paracol}

Not all functions are straight-forward to inline, recursive functions being part
of this subset, and subsequently an area of focus in this report.

\todo[inline]{Todo: Describe layout/outline of paper. What does each section in
turn discuss?}

This paper \todo{Todo: Fill in for the empty sections as they come.}details the
inliner for the new compiler backend Jive the decisions made for its
architecture, and evaluates its performance. Jive takes code in intermediate
representation (IR) as input and works on a new IR representation, the
regionalized value-state dependence graph (RVSDG\footnote{Detailed in Section
\ref{background:RVSDG}.}).

We will also discuss how the inlining heuristics in the Jive backend are used,
and how the heuristic can be controlled/modified. Further details of the
assignment of this paper can be found in Appendix \ref{app:projdesc}.
