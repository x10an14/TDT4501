% !TEX root = ./report.tex

\section{Introduction}
\label{introduction}

Since the 1950s, compilers have played an important role in the way programming
code is translated into machine languages. In broad terms, compilers perform two
actions: the translation from human-readable code to machine language, and
optimizing the translated programs. There exist many optimization techniques
compilers use. One such technique is inlining, where the call site of a function
is replaced by the body of the function, as shown in Listing \ref{lst:inlining}.

\begin{lstlisting}[label={lst:inlining}, style=customcpp,
caption={Function \textit{foo()} inlined into function \textit{bar()} would
result in the body of \textit{bar()} being \textit{return x + 3 + 2}, in which
case the optimization technique of constant folding is unveiled, permitting the
compiler to replace the expression with its cheaper equivalent: \textit{x +
5}.}]
int foo(int x){
	return x + 3;
}

int bar(int y){
	return foo(y) + 2;
}
\end{lstlisting}
\vspace{-4\parskip} %http://tex.stackexchange.com/q/40863

The benefits are manifold. Removal of function call overhead, and a potential
for unveiling the application of additional optimizations being among these. The
drawbacks is potential code-duplication, exemplified in Listing~\ref{lst:code-dup},
and in certain specific situations work-duplication\footnote{As detailed by P.
Jones and Marlow~\cite{GHCPaper} to be the case for the \textit{Glasgow Haskell
Compiler}.}. Another potential drawback is negatively affected compile time, and
increased program executable size.

\begin{lstlisting}[label={lst:code-dup}, style=customcpp,
caption={Code duplication in \textit{bar()}, when inlining \textit{foo()} into
\textit{bar()}. The big expression \textit{e} in \textit{foo()}, would be
duplicated when inlined into \textit{bar()}. This replaces the cost of function
call overhead with the increased size of the final program, unless potential
optimizations that counteract this are unveiled when inlining \textit{foo()}.}]
int foo(int a){
	return e; //Big expression, output of which depends on a's value
}

int bar(int x, int y){
	return f(x) + f(y);
}
\end{lstlisting}
\vspace{-4\parskip} %http://tex.stackexchange.com/q/40863

\todo[inline]{Consider removing: \\
Not all functions are straight-forward to inline, such as recursive functions.
At compile time, the needed depth of recursion might be unknown, leading to non-
termination of the compiler as it tried to inline the recursive function until
the necessary depth.}

This report describes the inliner project for the Jive compiler backend. It
details the decisions made for the inliner's architecture. Jive takes program
code in \textit{intermediate representation} (IR) as input and uses a new IR
representation, the \textit{Regionalized Value-State Dependence Graph}
(RVSDG\footnote{Detailed in Section \ref{background:RVSDG}.}).

\todo[inline]{Todo: In the below text (write it into the text) describe
layout/outline of paper. What does each section in turn discuss?}

The report will detail how the inliner is able to handle recursive functions,
and how the inliner permits the configuration of different heuristics to allow
rapid exploration of the parameter space. How the RVSDG affects the design of an
inliner, and the algorithms used by the heuristics deciding what to inline, is
also looked into in this report. Focus is put on whether the RVSDG simplifies or
complicates the implementation of the inliner (its impact), and the process of
inlining, compared to commonly used IRs.

Finally, the implemented inliner is evaluated before we conclude. In the
evaluation, focus will be put on how different heuristics have different
consequences, in terms of code-duplication, in addition to what impact the RVSDG
has on the design of an inliner.

A detailed description of the project assignment of this paper can be found in
Appendix~\ref{app:projdesc}.
