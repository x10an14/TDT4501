% !TEX root = ./report.tex

\section{Introduction}
\label{introduction}

Since the 1950s, compilers have played an important role in the way programming
code is translated into machine languages. In broad terms, compilers perform two
actions: the translation from human-readable code to machine language, and
optimizing the translated programs. There exist many optimization techniques
compilers use. One such technique is inlining, where the call site of a function
is replaced by the body of the function, as shown in Listing \ref{lst:inlining}.

\begin{lstlisting}[label={lst:inlining}, style=customcpp,
caption={Function \textit{foo()} inlined into function \textit{bar()} would
result in the body of \textit{bar()} being \textit{return x + 3 + 2}, in which
case the optimization technique of constant folding is unveiled, permitting the
compiler to replace the expression with its cheaper equivalent: \textit{x +
5}.}]

int foo(int x){
	return x + 3;
}

int bar(int y){
	return foo(y) + 2;
}
\end{lstlisting}

The benefits of manifold. Removal of function call overhead, and a potential for
unveiling the application of additional optimizations being among these. The
drawbacks are potential code- and work- duplication, shown in
Listings~\ref{lst:code-dup}. Additionally, inlining can also negatively affect
the compile time, and program executable size.

\begin{lstlisting}[label={lst:code-dup}, style=customcpp,
caption={Code duplication in \textit{bar()}, when inlining \textit{foo()} into
\textit{bar()}. Total code size (counted by number of statements) for the
functions \textit{foo()} and \textit{bar()} are 11 when not inlined, and 13 when
inlined.}]
typedef struct{
	int x;
	int y;
} coords_t;

coords_t* foo(int z){
	coords_t* a = (coords_t*) malloc(sizeof(coords_t));
	a->x = 1; a->y = 2;
	a->x *= z; a->y *= z;
	return a;
}

coords_t* bar(){
	coords_t* a = foo();
	coords_t* b = foo();

	b->x += a->x; b.y += a->y;
	return b;
}

// bar() with foo() inlined, with code duplication
coords_t* bar(int z){

	// Lines which are duplicated unnecessarily
	coords_t* a = (coords_t*) malloc(sizeof(coords_t));
	a->x = 1; a->y = 2;
	a->x *= z; a->y *= z;

	// Lines which are duplicating unnecessarily
	coords_t* b = (coords_t*) malloc(sizeof(coords_t));
	b->x = 1; b->y = 2;
	b->x *= z; b->y *= z;
	b->x += a->x; b.y += a->y;

	return b;
}
\end{lstlisting}

Not all functions are straight-forward to inline, such as recursive functions.
Only an unknown subset of all recursive functions can be inlined, and if one is
inlined incorrectly, it can lead to non-termination of the compiler. Recursive
functions, the heuristics parameter space, and how the inliner enables rapid
exploration of the parameter space, are other topics this report will discuss in
turn.

This report describes the inliner for the new compiler backend Jive. It will
detail the decisions made for its architecture and heuristics. Jive takes
program code in Intermediate Representation (IR) as input and works on a new IR
representation, the Regionalized Value-State Dependence Graph
(RVSDG\footnote{Detailed in Section \ref{background:RVSDG}.}).

\todo[inline]{Todo: In the below text (write it into the text) describe
layout/outline of paper. What does each section in turn discuss?}

How the RVSDG affects the design of an inliner, and the process of inlining,
will also be looked into in this report. Focus will be put on whether the RVSDG
simplifies or complicates the implementation of the inliner, and the process of
inlining compared to commonly used IRs.

Finally, the implemented inlineris evaluated before we conclude. In the
evaluation, focus will be put on how different heuristics have different
consequences, in terms of code- and work-duplication.

Further details of the assignment of this paper can be found in Appendix
\ref{app:projdesc}.
