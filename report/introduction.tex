% !TEX root = ./report.tex

\section{Introduction}
\label{introduction}

Since the 1950s, compilers have been translating higher-level programming
languages into machine languages. The purpose of a compiler is two-fold:
translate human-readable code into machine language, and optimize the translated
code. Compilers use many code optimization techniques, such as \textit{Common
Subexpression Elimination} (CSE) and \textit{Dead Code Elimination} (DCE).

\todo[inline]{Find reference, if time allows. Nico says to look in Dragon book,
figure out where you can borrow that one.}

\info[inline]{There seems to be a big paper named ``Variable Subsumption with
Constant Folding'' by a ``Ken, Kennedy'', but I can't find the paper. It's from
1973-1974. Checked acm.org, citeseerx, google scholar. Should I cite it without
having read it? I would think not...}

Another code optimization is \textit{inlining}, which replaces the call site of
a function with its body. Listing~\ref{lst:inlining} shows the definition of
functions \lstinline!A()! and \lstinline!B()!. If \lstinline!A()! is inlined
into \lstinline!B!, the body of \lstinline!B()! becomes
\lstinline!return y + 3 + 2;!, allowing \textit{Constant Folding} (CF) to
replace \lstinline!3+2! with \lstinline!5!.

\begin{centering}
	\noindent\begin{minipage}{\textwidth}
		\begin{CenteredBox}
		\begin{lstlisting}[style=global_customcpp]
int A(int x){
	return x + 3;
}

int B(int y){
	return A(y) + 2;
}
		\end{lstlisting}
		\end{CenteredBox}
	\end{minipage}
	\captionof{lstlisting}{C/C++ code showing the definitions of \lstinline!A()!
and \lstinline!B()! when exemplifying CF.}
	\label{lst:inlining}
\end{centering}

The benefits of inlining are mainly two-fold: The first one is the removal of
function call overhead. Function call overhead is the cost in memory needed on
the stack, as well as the CPU cycles needed for setting up and performing the
call. The second is the potential for unveiling the application of additional
optimizations as demonstrated in Listing~\ref{lst:inlining}.

The drawbacks of inlining are code-duplication, and an increased compile time.
In specific situations, work-duplication can also occur~\cite{GHCPaper}.
Listing~\ref{lst:code-dup} exemplifies a situation where inlining can lead to
code-duplication, if \lstinline!C()! is inlined into \lstinline!D()!.
Code-duplication can occur since \lstinline!C()! is called more than once in
\lstinline!D()!. This is due to the big expression \lstinline!e! in
\lstinline!C()! is copied into \lstinline!D()! as soon as one or more of
invocations of \lstinline!C()! are inlined. However, code-duplication might be
mitigated if CSE is applicable. Also, if \lstinline!C()! is \lstinline!static!
with all its invocations inlined, then the definition of \lstinline!C()! may be
removed through the application of DCE.

\begin{centering}
	\noindent\begin{minipage}{\textwidth}
		\begin{CenteredBox}
		\begin{lstlisting}[style=global_customcpp]
static int C(int a){
	return e; //Big expression, depending on a
}

int D(int x, int y){
	return C(x) + C(y);
}
		\end{lstlisting}
		\end{CenteredBox}
	\end{minipage}
	\captionof{lstlisting}{C/C++ code showing the definitions of
\lstinline!C()! and \lstinline!D()!, when exemplifying code-duplication.}
	\label{lst:code-dup}
\end{centering}

If inlining is performed blindly on all function call sites, non-termination of
the compilation can occur. This can happen when the compiler attempts to inline
recursive functions. Hence, recursive functions need to be handled carefully.
The literature proposes mainly two approaches for inlining recursive functions:

\begin{enumerate}

	\item Avoid non-termination of the compilation by only inlining recursive
functions to a certain depth~\cite{GHCPaper}\cite{InlineWhenHowSerrano}, and
therefore breaking the recursive cycle.

	\item In a mutually recursive environment, decide on one or more functions
to be \textit{loop breakers}, and mark them to never be inlined. Loop breakers
are chosen so that the recursive call cycle will be broken in the mutually
recursive environment. Having chosen correct loop breakers permits inlining the
remaining recursive functions in the mutually recursive environment,
\textit{without} risking non-termination of the
compiler~\cite{BasMscThesis}\cite{GHCPaper}.

\end{enumerate}

This report describes the construction of an inliner for the Jive compiler
backend, detailing the design and architecture. Jive uses an
\textit{intermediate representation} (IR) called the \textit{Regionalized Value
State Dependence Graph}\footnote{Detailed in Section \ref{background:RVSDG}.}
(RVSDG).

The RVSDG~\cite{RVSDG:HiPEACpaper} described in Section~\ref{background:RVSDG},
is a \textit{demand-based} and \textit{directed acyclic graph} (DAG) where nodes
represent computations, and edges represent the dependencies between these
computations.

Section~\ref{sec:scheme} explains how the inliner is able to handle recursive
functions, and how the inliner permits the configuration of different heuristics
to allow rapid exploration of the parameter space. How the RVSDG affects the
design of an inliner, and the algorithms used by the heuristics deciding what to
inline, are also detailed in Section~\ref{sec:scheme}.

\todo[inline]{Finish describing layout/outline of paper. What do the remaining
sections discuss in turn?}

Focus is put on whether the RVSDG simplifies or complicates the implementation
of the inliner, as well as the impact of the RVSDG on an inliner, and the
process of inlining, \todo{Where in the report does Nico want this?}compared to
commonly used IRs.

In Section~\ref{sec:methodology}, the implemented inliner is evaluated
before we conclude in Section~\ref{sec:conclusion}. In the evaluation, we focus
on how different heuristics have different consequences, such as
code-duplication, and others.

Finally, in Section~\ref{sec:further_work} we discuss ideas for potential
further research. A detailed description of the project assignment can be found
in Appendix~\ref{app:projdesc}.
