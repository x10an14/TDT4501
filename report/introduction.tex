% !TEX root = ./report.tex

\section{Introduction}
\label{introduction}

Since the 1950s, compilers have played an important role in the way programming
code is translated into machine languages. In broad terms, compilers perform two
actions: the translation from human-readable code to machine language, and
optimizing the translated programs. There exist many optimization techniques
compilers use. One such optimization is inlining, a straight-forward
optimization which replaces the call of a function with its body. See example
below in Listing \ref{lst:inlining}.

\begin{center}
	\noindent\begin{minipage}{0.48\textwidth}
		\begin{lstlisting}[label={lst:inlining}, style=customcpp,
caption={Function \textit{foo()} inlined into function \textit{bar()}.}]
int foo(int x){
	return x + 3;
}

int bar(int y){
	return foo(y) + 2;
}

// bar() with foo() inlined:
int bar(int y){
	y + 3 + 2;
}
		\end{lstlisting}
	\end{minipage}
	\noindent\begin{minipage}{0.48\textwidth}
		\begin{lstlisting}[label={lst:work-dup}, style=customcpp,
caption={Work duplication in \textit{bar()}, when inlining \textit{foo()} into
\textit{bar()} due to the twice over calculation of \textit{foo(y)}.}]
int foo(int x){
	//Computationally expensive function,
	//such as Fibonacci for very high numbers
}

int bar(int y){
	return foo(y) + foo(y+4000);
}
		\end{lstlisting}
	\end{minipage}
\end{center}
However, the decision of which functions to inline has long been treated as
``black magic'', due to the non-existence of a perfect inlining heuristic. This
report attempts to answer exactly that question for the new compiler backend
Jive, introduced shortly.

The benefits of inlining are removal of function call overhead, and a potential
for unveiling additional optimizations. The drawbacks are potential code- and
work- duplication, shown in Listings \ref{lst:code-dup} and \ref{lst:work-dup},
respectively. Additionally, inlining can also negatively affect the compile
time, and program executable size\footnote{Unless optimizations to counteract
this are unveiled.}.

\begin{lstlisting}[label={lst:code-dup}, style=customcpp,
caption={Code duplication in \textit{bar()}, when inlining \textit{foo()} into
\textit{bar()}.}]
typedef struct{
	int x;
	int y;
} coords_t;

coords_t* foo(int z){
	coords_t* a = (coords_t*) malloc(sizeof(coords_t));
	a->x = 1; a->y = 2;
	a->x *= z; a->y *= z;
	return a;
}

coords_t* bar(){
	coords_t* a = foo();
	coords_t* b = foo();

	b->x += a->x; b.y += a->y;
	return b;
}

// bar() with foo() inlined, with code duplication
coords_t* bar(){

	// Lines which are duplicated unnecessarily
	coords_t* a = (coords_t*) malloc(sizeof(coords_t));
	a->x = 1; a->y = 2;

	// Lines which are duplicating unnecessarily
	coords_t* b = (coords_t*) malloc(sizeof(coords_t));
	b->x = 1; b->y = 2;

	b->x += a->x; b.y += a->y;
	return b;
}
\end{lstlisting}

Not all functions are straight-forward to inline, such as recursive functions.
Only an unknown subset of all recursive functions can be inlined, and if one is
inlined incorrectly, it can lead to non-termination of the compiler. Recursive
functions, the heuristics parameter space, and how the inliner enables rapid
exploration of the parameter space, are other topics this report will discuss in
turn.

This report describes the inliner for the new compiler backend Jive. It will
detail the decisions made for its architecture and heuristics. Jive takes
program code in Intermediate Representation (IR) as input and works on a new IR
representation, the Regionalized Value-State Dependence Graph
(RVSDG\footnote{Detailed in Section \ref{background:RVSDG}.}).

\todo[inline]{Todo: In the below text (write it into the text) describe
layout/outline of paper. What does each section in turn discuss?}

How the RVSDG affects the design of an inliner, and the process of inlining,
will also be looked into in this report. Focus will be put on whether the RVSDG
simplifies or complicates the implementation of the inliner, and the process of
inlining compared to commonly used IRs.

Finally, the implemented inlineris evaluated before we conclude. In the
evaluation, focus will be put on how different heuristics have different
consequences, in terms of code- and work-duplication.

Further details of the assignment of this paper can be found in Appendix
\ref{app:projdesc}.
