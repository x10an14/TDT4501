% !TEX root = ./report.tex

\section{Introduction}
\label{introduction}

Since the 1950s, compilers played an important role in the way higher-level
programming languages are translated into machine languages. The purpose of
compilers is two-fold: the translation of human-readable code into machine
language, and optimizing the translated code. There exist many optimization
techniques compilers use, such as \textit{Common Subexpression Elimination}
(CSE) and \textit{Dead Code Elimination} (DCE). Another one is inlining, which
replaces the call site of a function with its body, shown in
Listing~\ref{lst:inlining}.

\begin{lstlisting}[label={lst:inlining}, style=customcpp,
caption={Function \lstinline!foo()! inlined into function \lstinline!bar()!
results in the body of \lstinline!bar()! being \lstinline!return x + 3 + 2!, in
which case constant folding can be applied, replacing the \textit{return}
expression of \lstinline!bar()! with: \lstinline!x + 5!.}]
int foo(int x){
	return x + 3;
}

int bar(int y){
	return foo(y) + 2;
}
\end{lstlisting}
\vspace{-4\parskip} %http://tex.stackexchange.com/q/40863

The benefit of inlining are mainly twofold: The first one is the removal of
function call overhead. The second is the potential for unveiling the
application of additional optimizations as shown in Listing~\ref{lst:inlining}.
The drawbacks of inlining are potential code-duplication as exemplified in
Listing~\ref{lst:code-dup}, in specific situations work-duplication\footnote{As
detailed by P. Jones and Marlow~\cite{GHCPaper}.}, and increase of compile time.

\begin{lstlisting}[label={lst:code-dup}, style=customcpp,
caption={Code duplication in \lstinline!bar()!, when inlining \lstinline!foo()!
into \lstinline!bar()!. The big expression \lstinline!e! in \lstinline!foo()!,
would be duplicated when inlined into \lstinline!bar()!, potentially leading to
code-duplication. However, CSE might be able to mitigate code-duplication.}]
int foo(int a){
	return e; //Big expression, depending on a
}

int bar(int x, int y){
	return f(x) + f(y);
}
\end{lstlisting}
\vspace{-4\parskip} %http://tex.stackexchange.com/q/40863

Another factor to consider are recursive functions. Inlining recursive functions
uncontrolled leads to non-termination of the compilation. This report will
discuss the following techniques used to avoid this in the project:

(1) Only inline the function \lstinline!X! times, where \lstinline!X! is a
maximum recursion depth\cite{GHCPaper}\cite{InlineWhenHowSerrano}. (2) If there
are recursive bindings, make a dependency graph of the recursive calls, and scan
the graph for \textit {strongly-connected components} which can then be broken.
The key insight being that \textit{the inliner cannot loop if every cycle in the
recursive dependency call graph is broken by a call that is never
inlined}\cite{BasMscThesis}\cite{GHCPaper}.

This report describes the construction of an inliner for the Jive compiler
backend. It details the decisions made for the architecture of the inliner. Jive
works on an \textit{intermediate representation} (IR) called
\textit{Regionalized Value-State Dependence Graph}\footnote{Detailed in Section
\ref{background:RVSDG}.} (RVSDG). The RVSDG is a \textit{demand based} DAG
(\textit{directed acyclic graph}) representing the operations performed by any
program through nodes, and any dependences between the nodes with
edges. Bahmann et. al~\cite{RVSDG:HiPEACpaper} show how there is no intrinsic
structural limitation in the control flow directly extractable from RVSDGs. They
also prove in their report termination and correctnes of programs converted from
a CFG (\textit{Control Flow Graph}) IR into an RVSDG and back again, without
imposing additional overhead on the control flow of the produced object code.

\todo[inline]{In the below paragraph; describe layout/outline of paper. What
does each section in turn discuss?}

This report details how the inliner is able to handle recursive functions, and
how the inliner permits the configuration of different heuristics to allow rapid
exploration of the parameter space. How the RVSDG affects the design of an
inliner, and the algorithms used by the heuristics deciding what to inline, are
also detailed in this report. Focus is put on whether the RVSDG simplifies or
complicates the implementation of the inliner, as well as the impact of the
RVSDG on an inliner, and the process of inlining, compared to commonly used IRs.

Finally, the implemented inliner is evaluated before we conclude. In the
evaluation, focus is put on how different heuristics have different
consequences, in terms of code-duplication. A detailed description of the
project assignment can be found in Appendix~\ref{app:projdesc}.
