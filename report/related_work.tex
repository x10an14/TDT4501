% !TEX root = ./report.tex

\section{Related Work}

In this section (...)\todo[inline]{To do...}

\subsection{Regionalized Value-State Dependency Graph}
\todo[inline]{Insert reference/summary of HiPEAC paper when published}

\subsection{Inlining}

Cavazos and F.P. O'Boyle \cite{AutoTuningJavaHeuristics} explores the heuristic
approach on when to inline functions, and in its paper shows how conjunctive
normalform can easily be used to decide if and when to inline a specific call
site. They report between 17\% and 37\% execution time improvements without
code explosion in their testing of their genetic algorithm auto-tuning.

Serrano \cite{InlineWhenHowSerrano} explains when to inline functions in the
Scheme programming language, by classifying them as either recursive or  non-
recursive functions, and thereafter mainly inlining non-recursive functions if
they do not bloat the code size above a certain treshold.

Serrano \cite{InlineWhenHowSerrano} also takes overhead into account when
deciding on when to inline, and hence also looks at inlining certain recursive
functions which fulfill some requirements, at least to a certain \todo{Find a
good reference?}depth.

\subsection{Recursive Inlining}

P. Jones and Marlow \cite{GHC-paper} explore how the decision of when to inline
mutually recursive binding groups in Haskell, through the use of a novel
approach using strictness-analysis and forming a graph of the strongly connected
components (\textbf{SCC}) in said mutually recursive binding group.

They also show how this approach in the Haskell core language does not explode
code size when inlining some of the recursive functions. Through the use of
their SCC they show how instead of not inlining any recursive function (like
Serrano \cite{InlineWhenHowSerrano}), the SCC graph and some other flags can
show when it is not only safe, but desirable to inline a recursive function.
