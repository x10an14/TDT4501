% !TEX root = ./report.tex

\section{Related Work}

In this section (...)\todo[inline]{To do...}

\subsection{Regionalized Value-State Dependency Graph}
\todo[inline]{Insert reference/summary of HiPEAC paper when published}

\subsection{Inlining}

Cavazos and F.P. O'Boyle \cite{AutoTuningJavaHeuristics} explores the heuristic
approach on when to inline functions, and in its paper shows how conjunctive
normalform can easily be used to decide if and when to inline a specific call
site. They report between 17\% and 37\% execution time improvements without
code explosion in their testing of their genetic algorithm auto-tuning.

Serrano \cite{InlineWhenHowSerrano} explains when to inline functions in the
Scheme programming language, by classifying them as either recursive or non-
recursive functions, and thereafter mainly inlining non-recursive functions if
they do not bloat the code size above a certain treshold.

Serrano \cite{InlineWhenHowSerrano} also takes overhead into account when
deciding on when to inline, and hence also looks at inlining certain recursive
functions which fulfill some requirements, at least to a certain \todo{Find a
good reference?}depth.

Waterman's Ph.D. thesis \cite{AdaptvCompilAndInlingWaterman} examines the use of
techniques to adaptively decide which functions to inline during program
compilation, to show that they can be used to improve the performance of
specific optimizations.

The adaptive technique both matches, and at times, beats ATLAS \todo{need ATLAS
cite?} and gcc on one of the object oriented biggest programs in the SPEC
CINT2000 test suite. The technique accepts condition strings (like in
\cite{AutoTuningJavaHeuristics}) to determine which call sites are inlined. The
condition strings provide a flexible inliner by combining various program
properties in CNF, and exposes a large space of different inlining decisions
with the potential to outperform static techniques when used adaptively.

\subsection{Recursive Inlining}

P. Jones and Marlow \cite{GHC-paper} explore how the decision of when to inline
mutually recursive binding groups in Haskell, through the use of a novel
approach using strictness-analysis and forming a graph of the strongly connected
components (\textbf{SCC}) in said mutually recursive binding group.

They also show how this approach in the Haskell core language does not explode
code size when inlining some of the recursive functions. Through the use of
their SCC they show how instead of not inlining any recursive function (like
Serrano \cite{InlineWhenHowSerrano}), the SCC graph and some other flags can
show when it is not only safe, but desirable to inline a recursive function.
