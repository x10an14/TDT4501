% !TEX root = ./report.tex

\clearpage
\section{Methodology}
\label{sec:methodology}

\todo[inline]{Need an introduction here, no?}

\subsection{The Inlining Conditions (ICs)}
\label{sub:meth:inlining_conditions}

The ICs utilized in this project are the following:

\begin{itemize}

	\item \textbf{Statement count (SC)}

This function property equates to the number of C/C++ statements contained
within a function. A function's statement count is an inliner condition we want
to utilize because it gives us an idea of the size of the code-duplication if we
inline the function.

	\item \textbf{Loop nesting depth (LND)}

This property tells us how potentially useful it is to inline this specific call
site. The assumption is that most of a program's execution time is spent within
loops, so there is potentially more to gain if optimizations are unveiled by
inlining call sites inside nested loops.

	\item \textbf{Static call count (SCC)}

This property tells us how many call sites there are for this function in the
program. If this count is low, it may be worth inlining all the call sites and
eliminating the original function. If the count is $1$, then the call site can
always be inlined, seeing as there is no risk of code-duplication.

	\item \textbf{Parameter count (PC)}

The greater the amount of parameters a function has, the greater the invocation
cost of said function. This is especially true when type conversion is required.
In some cases, the computational cost of an inlined with low statement count may
be smaller than the cost of invoking it if it has many
parameters~\cite{AdaptvCompilAndInlingWaterman}.

	\item \textbf{Constant parameter count (CPC)}

This property tells us how many of the call site's parameters are constant at
the call site. Function invocations with constant parameters can often benefit
more from unveiled optimizations after inlining.s

	\item \textbf{Calls in procedure (CP)}

This function property tells us how many call sites are located inside the
function the call site invocates. Hence, it enables finding leaf functions.
Waterman~\cite{AdaptvCompilAndInlingWaterman} introduced this parameter for two
distinct reasons: leaf functions are often small and easily inlined, and a high
percentage of total execution time is spent in leaf functions.

\end{itemize}
