% !TEX root = ./report.tex

\clearpage
\section{Methodology}
\label{sec:methodology}

\todo[inline]{Need an introduction here, no?}

\subsection{The Inlining Conditions (ICs)}
\label{sub:meth:inlining_conditions}

The ICs utilized in this project are the following:

\begin{itemize}

	\item \textbf{Node Count (NC)}

This function property equates to the number of C/C++ statements contained
within a function. A function's node count is an inliner condition we want
to utilize because it gives us an idea of the size of the  duplication if we
inline the function.

	\item \textbf{Loop Nesting Depth (LND)}

This call site property tells us how potentially useful it is to inline this
specific call site. The assumption is that most of a program's execution time is
spent within loops, so there is potentially more to gain if optimizations are
unveiled by inlining call sites inside nested loops.

	\item \textbf{Static Call Count (SCC)}

This property tells us how many call sites invoke this function in the program.
If this count is low, it may be worth inlining all the call sites and
eliminating the original function. For example, if the count is $1$, then the
call site can always be inlined, seeing as there is no risk of  duplication.

	\item \textbf{Parameter Count (PC)}

The greater the amount of parameters a function has, the greater the invocation
cost of said function. This is especially true when type conversion is required.
In some cases, the computational cost of an inlined with low node count may
be smaller than the cost of invoking it if it has many
parameters~\cite{AdaptvCompilAndInlingWaterman}.

	\item \textbf{Constant Parameter Count (CPC)}

This property tells us how many of the call site's parameters are constant at
the call site. Function invocations with constant parameters can often benefit
more from unveiled optimizations after inlining.

	\item \textbf{Calls In Node (CIN)}

This function property tells us how many call sites are located inside the
function the call site being evaluated invokes. Hence, it enables the finding of
leaf functions. Waterman~\cite{AdaptvCompilAndInlingWaterman} introduced this
parameter for two distinct reasons: leaf functions are often small and easily
inlined, and a high percentage of total execution time is spent in leaf
functions.

\end{itemize}
