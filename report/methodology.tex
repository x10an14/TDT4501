% !TEX root = ./report.tex

\clearpage
\section{Methodology}
\label{sec:methodology}

Using the \textit{Inliner Conditions} (ICs) described in
Section~\ref{sub:meth:inlining_conditions}, the inliner of this project has been
tested using C-language programming files from the SPEC2006 Benchmark Suite.
This section first details the ICs, before explaining how the files tested from
the SPEC2006 Benchmark Suite were chosen. Finally, we list the CNFs for each
group of files from the SPEC2006 Benchmark Suite the inliner ran the benchmarks
with.

\subsection{The Inlining Conditions}
\label{sub:meth:inlining_conditions}

The ICs utilized in this project are as follow:

\begin{itemize}

	\item \nopagebreak{\textbf{Node Count }(NC)}

This function property represents the number of operations (nodes) contained
within a function. A function's node count is an IC we want to utilize because
it gives us an indication for what the upper limit of potential code duplication
might become, if we inline the function.

	\item \nopagebreak{\textbf{Loop Nesting Depth }(LND)}

This call site property tells us how potentially useful it is to inline this
specific call site. The assumption is that most of a program's execution time is
spent within loops, so there is potentially more to gain if optimizations are
unveiled by inlining call sites inside nested loops.

	\item \nopagebreak{\textbf{Static Call Count }(SCC)}

This property tells us how many call sites invoke this function in the program.
If this count is low, it may be worth inlining all the call sites and
eliminating the original function. For example, if the count is $1$, and the
function is not exported, then the call site can always be inlined since there
is no risk of code duplication.

	\item \nopagebreak{\textbf{Parameter Count }(PC)}

The greater the amount of parameters a function has, the greater the invocation
cost of said function. This is can especially be the case when type conversion
is required~\cite{AdaptvCompilAndInlingWaterman}. In some cases, the
computational cost of an inlined function with low node count may be smaller
than the cost of invoking it if it has many
parameters~\cite{AdaptvCompilAndInlingWaterman}.

	\item \nopagebreak{\textbf{Constant Parameter Count }(CPC)}

This property tells us how many of the call site's parameters are constant at
the call site. Function invocations with constant parameters can often benefit
more from unveiled optimizations after inlining.

	\item \nopagebreak{\textbf{Calls In Node }(CIN)}

This function property tells us how many call sites are located inside the
function the call site being evaluated invokes. Hence, it enables the finding of
leaf functions. Waterman~\cite{AdaptvCompilAndInlingWaterman} introduced this
parameter for two distinct reasons: leaf functions are often small and easily
inlined, and a high percentage of total execution time is spent in leaf
functions.

\end{itemize}

\subsection{The SPEC2006 Benchmark Suite files}
\label{sub:meth:SPEC2006_files}

The SPEC2006 Benchmark Suite files were chosen with the following criteria:

\begin{enumerate}
	\item \nopagebreak{The Benchmark Suite program code files were written in C.}

	\item \nopagebreak{Clang}-3.4 (on Ubuntu 14.04) was able to convert the inputted C files
to LLVM IR assembly code with the \lstinline!-S! and \lstinline!-emit-llvm!
flags.

	\item \nopagebreak{Jive was able to interpret all of the assembly instructions in the}
outputted .ll files and construct RVSDGs from them.

	\item \nopagebreak{The files could to be tested within a time limit of 200}
seconds\footnote{This due to a bug in the supplied library needed for compiling
an executable using Jive.}, executed single-process, on a Intel(R) Core(TM)
i5-4200M CPU @ 2.50GHz, with 3072 KB cache size, Ubuntu 14.04 64-bit Linux
distro.
\end{enumerate}

With these requirements, files from the following benchmarks were used for
testing:

\begin{multicols}{3}
	\begin{itemize}
		\item \nopagebreak{400.perlbench \newline \textit{w/X .c files}}
		\item \nopagebreak{401.bzip2 \newline \textit{w/X .c files}}
		\item \nopagebreak{403.gcc \newline \textit{w/X .c files}}
		\item \nopagebreak{429.mcf \newline \textit{w/X .c files}}
		\item \nopagebreak{433.milc \newline \textit{w/X .c files}}
		\item \nopagebreak{435.gromacs \newline \textit{w/X .c files}}
		\item \nopagebreak{445.gobmk \newline \textit{w/X .c files}}
		\item \nopagebreak{456.hmmer \newline \textit{w/X .c files}}
		\item \nopagebreak{458.sjeng \newline \textit{w/X .c files}}
		\item \nopagebreak{462.libquantum \newline \textit{w/X .c files}}
		\item \nopagebreak{464.h264ref \newline \textit{w/X .c files}}
		\item \nopagebreak{470.lbm \newline \textit{w/X .c files}}
		\item \nopagebreak{482.sphinx3 \newline \textit{w/X .c files}}
	\end{itemize}
\end{multicols}

See Appendix~\ref{app:SPEC2006_files_used} for the complete list of .c files
used for testing from each of the above benchmarks from SPEC2006.

\subsection{CNF clauses common for all SPEC2006 Benchmark Suites used}
\label{sub:meth:common_CNFs}

The heuristics used to decide whether or not to inline a call site are written
with boolean logic in Conjunctive Normal Form (CNF) using the ICs from
Section~\ref{sub:meth:inlining_conditions}.

However, a CNF expression whose clauses are ideal for one program will not be
ideal for all programs. For some programs, it might even lead to a worse
executable than if no inlining had been performed at all. Hence, for each
SPEC2006 benchmark suite's .c files which passed the requirements listed in
Section~\ref{sub:meth:SPEC2006_files}, we profiled the .c files and found the
following CNFs for each set to be the most decent ones we could find manually.
See Section~\ref{sub:res:profiling} for the data found when profiling the
SPEC2006 Benchmark Suite files.

While a certain CNF may be ideal for the optimization of one program, the same
does not hold for all. Even so, there are some CNF clauses which are worth
keeping in all the CNFs used in our testing. These are as follow:

\begin{itemize}
	\item $SCC == 1$

This clause simply states that if there's only \textit{one} call site invoking
this function, and that the function is not exported, then it can be inlined
without worry of code duplication or work duplication.

	\item \unsure[inline]{Think of more...?}
\end{itemize}

\subsection{SPEC2006 Benchmark Suite's individual CNFs}
\label{sub:meth:SPEC2006_heuristics}

In addition to the CNF clauses from Section~\ref{sub:meth:common_CNFs} and
through manual testing of ICs and values, the following CNFs were the most
optimal ones we found for each individual SPEC2006 Benchmark Suite:

\begin{multicols}{2}
	\begin{itemize}
		\item 400.perlbench
		\item 401.bzip2
		\item 403.gcc
		\item 429.mcf
		\item 433.milc
		\item 435.gromacs
		\item 445.gobmk
		\item 456.hmmer
		\item 458.sjeng
		\item 462.libquantum
		\item 464.h264ref
		\item 470.lbm
		\item 482.sphinx3
	\end{itemize}
\end{multicols}

In an ideal world, we should not have looked for the most optimal CNFs ourselves
manually. However, since implementing implementing a randomized hillclimber to
find a good CNF per program compiled~\cite{AdaptvStratInlSubst} is outside of
the scope of this project, we did not have the resources to implement one.
